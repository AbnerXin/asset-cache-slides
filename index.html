<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>Static Asset Cache</title>

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/wx.css">

    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="lib/css/zenburn.css">

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>
  </head>
  <body>
    <div class="reveal">
      <div class="slides">
        <section data-markdown>
          <script type="text/template">
            <h2>Static Asset Cache</h1>
            <h4>Optimizing Static Asset Loading</h3>
            <p>
              <small>Create by <a> Abner Xin </a></small>
            </p>
          </script>
        </section>

        <section data-markdown>
          <script type="text/template">
            <ul>
              <li>
                <a href="#/3">HTTP headers</a>
              </li>
              <li>
                <a href="#/4">Cache with version info</a>
              </li>
            </ul>
          </script>
        </section>

        <section>
          <section> 
            <h2>HTTP headers</h2>
            <p>
              There are two ways to implement asset cache use http headers. 
              <span class="fragment"> Use Web Server (Nginx， Apache ...). </span> 
              <span class="fragment"> Set response headers in backend. </span> 
            </p>
          </section>

          <section data-markdown>
            <script type="text/template">
              <h3>Caching Method 1: Last-Modified</h3>
              ```
              // response headers
              Last-modified: Fri, 16 Mar 2007 04:00:25 GMT

              // request headers
              If-Modified-Since:Wed, 15 Mar 2017 12:02:32 GMT
              ```
              <img src="./images/HTTP-caching-last-modified_1.png">
            </script>
          </section>

          <section data-markdown>
            <script type="text/template">
              <h3>Caching Method 2: ETag</h3>
              ```
              // Two types of ETag
              "123456789"    – A strong ETag validator
              W/"123456789"  – A weak ETag validator

              // response headers
              ETag: W/"590-15ad1d92215"

              // request headers
              If-None-Match: W/"1be94-15ad1d9220d"
              ```
              <img src="./images/HTTP_caching_if_none_match.png">
            </script>
          </section>

          <section data-markdown>
            <script type="text/template">
              <h3>Caching Method 3: Expires</h3>
              ```
              Expires: Wed, 15 Mar 2017 12:39:27 GMT
              ```
              <img src="./images/HTTP_caching_expires.png">
            </script>
          </section>

          <section data-markdown>
            <script type="text/template">
              <h3>Caching Method 4: Cache-Control</h3>
              ```
              Cache-Control: public, max-age=300
              public  means the cached version can be saved by proxies and other intermediate servers, where everyone can see it.
              private means the file is different for different users (such as their personal homepage). The user’s private browser can cache it, but not public proxies.
              no-cache  means the file should not be cached. This is useful for things like search results where the URL appears the same but the content may change.
              ```
              <img src="./images/HTTP_caching_expires.png">
            </script>
          </section>

          <section data-markdown>
            <script type="text/template">
              ### Summary

              Whether use Etag or Last-Modified, the client still need know whether the cached asset is latest version, still need connect with server.

              Use Expires or Cache-Control, before the expires, there are no connection between client and server, but, the client can get the latest version
            </script>
          </section>
        </section>

        <section>
          <section data-markdown>
            <script type="text/template">
             In order to avoid the disadvantages of use http headers, we can rewrite the require path of static asset with query string.
              ```
              // index.html
              <link rel="stylesheet" href="style/a.css?v=1.0.0">

              // a.css
              .class {
                collor: #FFF;
              }
              ```
              <span class="fragment"> If we have a new version, only change the file a.css, but all cached asset will be invalidsend. </span> 
            </script>
          </section>

          <section data-markdown>
            <script type="text/template">
              Online version

              ```

              // Online version
              // index.html
              <link rel="stylesheet" href="style/a.css?v=123456">

              // a.css
              .class {
                collor: #FFF;
              }

              // new version
              // index.html
              <link rel="stylesheet" href="style/a.css?v=654321">

              // a.css
              .class {
                collor: #000;
              }
              ```
              <span class="fragment"> Some proxies or CDNs aren’t even able to cache files that contain query strings and it is recommended not to use them. </span> 
            </script>
          </section>

          <section data-markdown>
            <script type="text/template">
              <h2>The best way: Changing File Name</h2>
              Use fingerprinting to get the file name. Fingerprinting is a technique that makes the name of a file dependent on the *contents* of the file.
            </script>
          </section>

          <section data-markdown>
            <script type="text/template">
            </script>
          </section>
        </section>
      </div>
    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.js"></script>

    <script>
      // More info https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        history: true,

        // More info https://github.com/hakimel/reveal.js#dependencies
        dependencies: [
          { src: 'plugin/markdown/marked.js' },
          { src: 'plugin/markdown/markdown.js' },
          { src: 'plugin/notes/notes.js', async: true },
          { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
        ]
      });
    </script>
  </body>
</html>
